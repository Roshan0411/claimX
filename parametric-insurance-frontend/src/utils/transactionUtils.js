// Transaction utilities for handling history actions
import jsPDF from 'jspdf';
import 'jspdf-autotable';

export class TransactionUtils {
  // Blockchain explorer URLs for different networks
  static EXPLORER_URLS = {
    11155111: 'https://sepolia.etherscan.io', // Sepolia
    1: 'https://etherscan.io', // Mainnet
    137: 'https://polygonscan.com', // Polygon
    56: 'https://bscscan.com' // BSC
  };

  /**
   * Open transaction hash in blockchain explorer
   * @param {string} txHash - Transaction hash
   * @param {number} chainId - Blockchain network ID
   */
  static viewOnExplorer(txHash, chainId = 11155111) {
    const baseUrl = this.EXPLORER_URLS[chainId] || this.EXPLORER_URLS[11155111];
    const explorerUrl = `${baseUrl}/tx/${txHash}`;
    
    // Open in new tab
    window.open(explorerUrl, '_blank', 'noopener,noreferrer');
  }

  /**
   * Generate and download PDF receipt for a transaction
   * @param {Object} transaction - Transaction data
   * @param {string} userAccount - User's wallet address
   */
  static downloadReceipt(transaction, userAccount) {
    try {
      const doc = new jsPDF();
      
      // Company branding
      doc.setFontSize(20);
      doc.setTextColor(40, 116, 240);
      doc.text('ClaimX Insurance', 20, 25);
      
      doc.setFontSize(12);
      doc.setTextColor(100, 100, 100);
      doc.text('Parametric Insurance Platform', 20, 35);
      
      // Receipt title
      doc.setFontSize(16);
      doc.setTextColor(0, 0, 0);
      doc.text('Transaction Receipt', 20, 55);
      
      // Transaction details
      const receiptData = [
        ['Transaction ID', transaction.id],
        ['Description', transaction.description],
        ['Amount', transaction.amount],
        ['Date', new Date(transaction.date).toLocaleDateString()],
        ['Status', transaction.status],
        ['Transaction Hash', transaction.txHash],
        ['Account', userAccount],
        ['Network', 'Sepolia Testnet']
      ];
      
      doc.autoTable({
        startY: 70,
        head: [['Field', 'Value']],
        body: receiptData,
        theme: 'grid',
        headStyles: { fillColor: [40, 116, 240] },
        margin: { left: 20, right: 20 }
      });
      
      // Footer
      const finalY = doc.lastAutoTable.finalY + 20;
      doc.setFontSize(10);
      doc.setTextColor(100, 100, 100);
      doc.text('Generated by ClaimX Insurance Platform', 20, finalY);
      doc.text(`Generated on: ${new Date().toLocaleString()}`, 20, finalY + 10);
      doc.text('This is an automated receipt. No signature required.', 20, finalY + 20);
      
      // Download the PDF
      const fileName = `ClaimX_Receipt_${transaction.id}_${Date.now()}.pdf`;
      doc.save(fileName);
      
      return true;
    } catch (error) {
      console.error('Error generating receipt:', error);
      throw new Error('Failed to generate receipt. Please try again.');
    }
  }

  /**
   * Export transaction history to PDF
   * @param {Array} transactions - Array of transaction objects
   * @param {string} userAccount - User's wallet address
   */
  static exportToPDF(transactions, userAccount) {
    try {
      const doc = new jsPDF();
      
      // Header
      doc.setFontSize(20);
      doc.setTextColor(40, 116, 240);
      doc.text('ClaimX Insurance', 20, 25);
      
      doc.setFontSize(14);
      doc.setTextColor(0, 0, 0);
      doc.text('Transaction History Report', 20, 40);
      
      doc.setFontSize(10);
      doc.setTextColor(100, 100, 100);
      doc.text(`Account: ${userAccount}`, 20, 50);
      doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 58);
      doc.text(`Total Transactions: ${transactions.length}`, 20, 66);
      
      // Prepare table data
      const tableData = transactions.map(tx => [
        tx.id,
        tx.description.substring(0, 40) + (tx.description.length > 40 ? '...' : ''),
        tx.amount,
        new Date(tx.date).toLocaleDateString(),
        tx.status,
        tx.txHash.substring(0, 16) + '...'
      ]);
      
      // Create table
      doc.autoTable({
        startY: 75,
        head: [['ID', 'Description', 'Amount', 'Date', 'Status', 'Tx Hash']],
        body: tableData,
        theme: 'striped',
        headStyles: { fillColor: [40, 116, 240] },
        styles: { fontSize: 8 },
        columnStyles: {
          1: { cellWidth: 50 },
          5: { cellWidth: 30 }
        },
        margin: { left: 10, right: 10 }
      });
      
      // Summary
      const finalY = doc.lastAutoTable.finalY + 15;
      const totalPremiums = transactions
        .filter(tx => tx.type === 'premium_payment' || tx.type === 'policy_creation')
        .reduce((sum, tx) => sum + parseFloat(tx.amount.replace(' ETH', '')), 0);
      
      const totalPayouts = transactions
        .filter(tx => tx.type === 'payout')
        .reduce((sum, tx) => sum + parseFloat(tx.amount.replace(' ETH', '')), 0);
      
      doc.setFontSize(12);
      doc.setTextColor(0, 0, 0);
      doc.text('Summary:', 20, finalY);
      doc.text(`Total Premiums Paid: ${totalPremiums.toFixed(2)} ETH`, 20, finalY + 10);
      doc.text(`Total Payouts Received: ${totalPayouts.toFixed(2)} ETH`, 20, finalY + 20);
      doc.text(`Net Activity: ${(totalPayouts - totalPremiums).toFixed(2)} ETH`, 20, finalY + 30);
      
      // Download
      const fileName = `ClaimX_History_${userAccount.substring(0, 8)}_${Date.now()}.pdf`;
      doc.save(fileName);
      
      return true;
    } catch (error) {
      console.error('Error exporting to PDF:', error);
      throw new Error('Failed to export PDF. Please try again.');
    }
  }

  /**
   * Export transaction history to CSV
   * @param {Array} transactions - Array of transaction objects
   * @param {string} userAccount - User's wallet address
   */
  static exportToCSV(transactions, userAccount) {
    try {
      // CSV headers
      const headers = [
        'Transaction ID',
        'Type',
        'Description',
        'Amount (ETH)',
        'Date',
        'Status',
        'Transaction Hash',
        'Account'
      ];
      
      // Convert transactions to CSV format
      const csvData = transactions.map(tx => [
        tx.id,
        tx.type,
        `"${tx.description}"`, // Wrap in quotes to handle commas
        tx.amount.replace(' ETH', ''),
        tx.date,
        tx.status,
        tx.txHash,
        userAccount
      ]);
      
      // Combine headers and data
      const csvContent = [headers, ...csvData]
        .map(row => row.join(','))
        .join('\n');
      
      // Create and download blob
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      
      if (link.download !== undefined) {
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `ClaimX_History_${userAccount.substring(0, 8)}_${Date.now()}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
      
      return true;
    } catch (error) {
      console.error('Error exporting to CSV:', error);
      throw new Error('Failed to export CSV. Please try again.');
    }
  }

  /**
   * Send transaction report via email (simulation - would integrate with email service)
   * @param {Array} transactions - Array of transaction objects
   * @param {string} userAccount - User's wallet address
   * @param {string} emailAddress - User's email address
   */
  static async emailReport(transactions, userAccount, emailAddress) {
    try {
      // This is a simulation - in production, you would integrate with:
      // - EmailJS for client-side email
      // - SendGrid, AWS SES, or similar for server-side email
      // - Your backend API to handle email sending
      
      console.log('Preparing email report...');
      
      // Simulate email preparation
      const reportData = {
        to: emailAddress,
        subject: 'ClaimX Insurance - Transaction History Report',
        userAccount,
        transactionCount: transactions.length,
        reportDate: new Date().toISOString(),
        transactions: transactions.map(tx => ({
          id: tx.id,
          description: tx.description,
          amount: tx.amount,
          date: tx.date,
          status: tx.status
        }))
      };
      
      // Simulate API call delay
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // In production, you would make an API call here:
      // const response = await fetch('/api/send-email-report', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify(reportData)
      // });
      
      console.log('Email report sent successfully to:', emailAddress);
      return {
        success: true,
        message: `Transaction history report has been sent to ${emailAddress}`
      };
      
    } catch (error) {
      console.error('Error sending email report:', error);
      throw new Error('Failed to send email report. Please try again.');
    }
  }

  /**
   * Validate email address format
   * @param {string} email - Email address to validate
   */
  static isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  /**
   * Format transaction amount for display
   * @param {string} amount - Amount string
   * @param {string} type - Transaction type
   */
  static formatAmount(amount, type) {
    const sign = type === 'payout' ? '+' : '-';
    return `${sign}${amount}`;
  }

  /**
   * Get transaction type display name
   * @param {string} type - Transaction type
   */
  static getTypeDisplayName(type) {
    const typeNames = {
      policy_creation: 'Policy Creation',
      claim_submission: 'Claim Submission',
      payout: 'Payout Received',
      premium_payment: 'Premium Payment'
    };
    return typeNames[type] || type;
  }
}

export default TransactionUtils;